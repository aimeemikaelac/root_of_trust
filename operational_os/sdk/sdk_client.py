#!/usr/bin/python3

import argparse
import requests
import time
import binascii
import base64
import ed25519

def check_attestation_ticket(base_url, ticket):
    url = "{}/{}".format(base_url, "attestation/result/{}".format(ticket))
    response = requests.get(url)
    if response.status_code == 200:
        return response.json()["attestation"], True
    elif response.status_code == 204:
        return None, True
    else:
        return None, False


def start_attestation(base_url, message_file):
    url = "{}/{}".format(base_url, "attestation/request")
    with open(message_file, "rb") as file_handle:
        attestation_data = file_handle.read(32)
    response = requests.post(url, data={
        "attestation_data": bytearray(attestation_data)
    })
    return response.json()["ticket"]

def get_public_key(base_url):
    url = "{}/{}".format(base_url, "public_key")
    response = requests.get(url)
    return response.json()["public_key"]

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--server",
        help="Server IP address or hostname",
        required=True
    )
    parser.add_argument(
        "--port",
        help="Server TCP port",
        type=int,
        default=80,
    )
    subparsers = parser.add_subparsers(dest="command")
    upload_parser = subparsers.add_parser('upload')
    attestation_parser = subparsers.add_parser('attestation')
    upload_parser.add_argument(
        "--program_file",
        help="ARM elf binary to run as the untrusted code",
        required=True
    )
    upload_parser.add_argument(
        "--enclave_file",
        help="Binary memory programming file generated by mb-objcopy that "
        "is the memory image for the microblaze program",
        required=True
    )
    attestation_parser.add_argument(
        "--message_file",
        help="Path to file containing message data"
    )
    attestation_group = attestation_parser.add_mutually_exclusive_group(
        required=True
    )
    attestation_group.add_argument(
        "--attestation_wait",
        help="Start an attestation with the input message and wait for a "
        "response, polling at the specified interval",
        type=int
    )
    attestation_group.add_argument(
        "--send_begin_attestation",
        help="Send the attestation data from the file and return the received "
        "ticket",
        action="store_true"
    )
    attestation_group.add_argument(
        "--check_ticket",
        help="Check the status of the attestation ticket",
        type=int
    )
    attestation_parser.add_argument(
        "--verification_file",
        help="File to verify in the remote attestation"
    )
    args = parser.parse_args()
    hostname = args.server
    port = args.port
    protocol = "http://"
    base_url = "{}{}:{}".format(protocol, hostname, port)
    if args.command == "upload":
        url = "{}/{}".format(base_url, "upload")
        files = {
            "binary": open(args.enclave_file, 'rb'),
            "program": open(args.program_file, 'rb')
        }
        data = {
            "binary_file_name":args.enclave_file
        }
        response = requests.post(url, files=files, data=data)
        response_json = response.json()
        if response.status_code != 202:
            print(
                "Error uploading file.\nStatus code: {}\nResponse: {}\n"
                .format(response.status_code, response.text)
            )

    if args.command == "attestation":
        if args.attestation_wait is not None:
            if args.message_file is None:
                print("Message data required to start attestation")
                sys.exit(-1)
            ticket = start_attestation(base_url, args.message_file)
            attestation_data = None
            while attestation_data is None:
                #TODO: keep alive here
                time.sleep(1)
                attestation_data = check_attestation_ticket(base_url, ticket)
            print("Attestation data:\n{}".format(attestation_data))
        elif args.send_begin_attestation:
            print("Ticket:\n{}".format(
                start_attestation(base_url, args.message_file)
            ))
        elif args.check_ticket is not None:
            attestation_data, exists = check_attestation_ticket(
                base_url, args.check_ticket
            )
            if attestation_data:
                server_public_key = bytearray(
                    binascii.unhexlify(get_public_key(base_url))
                )
                print("Attestation data:\n{}".format(attestation_data))
                print("Attestation length: {}".format(len(attestation_data)))
                attestation_binary = binascii.unhexlify(attestation_data)
                signature = bytearray()
                enclave_hash = bytearray()
                public_key = bytearray()
                enclave_message = bytearray()
                signed_message = bytearray()
                for i in range(0x40):
                    signature.append(attestation_binary[i])
                # print("Signature:\n0x{}")
                for i in range(0x40):
                    enclave_hash.append(attestation_binary[0x40 + i])
                for i in range(0x20):
                    public_key.append(attestation_binary[0x80 + i])
                for i in range(0xA0):
                    enclave_message.append(attestation_binary[0xA0 + i])
                for i in range(0x100):
                    signed_message.append(attestation_binary[0x40 + i])
                print("Public key:\n{}".format(binascii.hexlify(public_key)))
                print("Server Public key len:\n{}".format(
                    binascii.hexlify(server_public_key)
                ))
                print("Signed message:\n{}".format(
                    len(str(binascii.hexlify(signed_message), 'ascii'))
                ))
                print("Signature:\n{}".format(
                    str(binascii.hexlify(signature), 'ascii')
                ))
                vk = ed25519.VerifyingKey(
                    bytes(server_public_key)
                )
                # encoding="hex"
                print(vk.to_ascii(encoding="hex"))
                try:
                    vk.verify(
                        bytes(signature),
                        bytes(signed_message)
                    )
                    # binascii.hexlify(signature),
                    # binascii.hexlify(signed_message),
                    # encoding="hex"
                    print("Verification passed")
                except ed25519.BadSignatureError:
                    print("Verification failed")
                    sk,vk = ed25519.create_keypair()
                    print(vk.to_ascii(encoding="hex"))
            elif exists:
                print("Attestation pending")
            else:
                print("Ticket not found")
